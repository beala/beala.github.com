
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>/usr/sbin/blog</title>
  <meta name="author" content="Alex Beal">

  
  <meta name="description" content="The Problem Alice wants to send Bob an encrypted file over the Internet. Alice&#8217;s first attempt is to encrypt the file using 7-zip and send it &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://usrsb.in/blog/blog/page/3">
  <link href="/blog/favicon.png" rel="icon">
  <link href="/blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/blog/javascripts/modernizr-2.0.js"></script>
  <script src="/blog/javascripts/ender.js"></script>
  <script src="/blog/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/blog/atom.xml" rel="alternate" title="/usr/sbin/blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-27836693-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/blog/">/usr/sbin/blog</a></h1>
  
    <h2>Alex's Geekery Journal.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/blog/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:usrsb.in/blog" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="http://usrsb.in">Home</a></li>
  <li><a href="/blog/">Blog</a></li>
  <li><a href="/blog/tools">Tools</a></li>
  <li><a href="/blog/about">About</a></li>
  <li><a href="/blog/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/blog/2011/12/16/a-zero-knowledge-file-exchange/">A Zero-Knowledge File Exchange</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2011-12-16T13:14:00-07:00" pubdate data-updated="true">Dec 16<span>th</span>, 2011</time>
         &bull; <a rel="bookmark" href="/blog/blog/2011/12/16/a-zero-knowledge-file-exchange/">&infin;</a>
      </p>
    
  </header>

<div class="entry-content"><h2>The Problem</h2>

<p>Alice wants to send Bob an encrypted file over the Internet. Alice&#8217;s first attempt is to encrypt the file using 7-zip and send it as an attachment, but quickly realizes that Bob now has no way of decrypting the file. Alice could email the decryption key, but realizes that this is insecure. Why encrypt the file in the first place if she is going to email the key in plaintext? Another solution is to use public key encryption, but contrary to everything we&#8217;ve ever read about Alice and Bob, neither knows how to use GPG. Alex, a dashing computer-scientist-in-training and intrepid narrator of this post, decides to craft a solution. Here is his proposal.</p>

<h2>Goals</h2>

<p>The goal is to create an online service with the following characteristics. It will:</p>

<ol>
<li>Facilitate file exchanges between users.</li>
<li>Not require any accounts.</li>
<li>Not require downloaded software.</li>
<li>Be zero-knowledge. The web service itself must not have access to the decrypted file.</li>
</ol>


<p>In order to meet requirement (4), the service will need to store only encrypted files. This is easy enough. The service can let Alice encrypt the file in her browser, and then host the file, but then we still have the original problem to deal with. Once Bob retrieves the file, how can he access the decryption key? It seems that we have a chicken-or-the-egg problem. Alice and Bob can&#8217;t communicate securely because they don&#8217;t share a key, and they can&#8217;t share a key because they can&#8217;t communicate securely. If only there were some way for two parties to negotiate an encryption key over an insecure channel. Luckily, computer scientists have anticipated this need and come up with the <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman key exchange</a>.</p>

<h2>The Site</h2>

<p>Here&#8217;s a sketch of how the service will look to Alice and Bob. In the next section, I&#8217;ll explain the implementation.</p>

<ol>
<li>Alice initiates a file exchange by going to the website and entering the following information:

<ul>
<li>Bob&#8217;s email and cell.</li>
<li>Her email.</li>
<li>A secret password of her choosing (Alice&#8217;s secret key).</li>
</ul>
</li>
<li>The site sends the following to Bob:

<ul>
<li>An email containing a link.</li>
<li>A text message containing a secret code.</li>
</ul>
</li>
<li>Bob receives the email and link.

<ul>
<li>He navigates to the link and is prompted for the code he received in the text. He enters it.</li>
<li>He is granted access to a form, and he enters a secret password of his choosing (Bob&#8217;s secret key). This doesn&#8217;t need to be the same as Alice&#8217;s secret key.</li>
</ul>
</li>
<li>Alice receives an email saying the website is ready for her upload.

<ul>
<li>She clicks the link, enters her secret password, and selects her file. Her file gets encrypted in the browser and uploaded to the website.</li>
</ul>
</li>
<li>Bob gets an email saying the download is ready with a link to a retrieval webpage.

<ul>
<li>He clicks the link and enters his secret password.</li>
<li>It&#8217;s decrypted in the browser, and saved to his hard drive.</li>
</ul>
</li>
</ol>


<p>Readers familiar with the D-H key exchange may already see what&#8217;s going on here. The real trick is in steps (3) and (4) where Alice and Bob are both able to generate a shared secret key without the web service having access to it. Bob and Alice can then encrypt files using the shared secret, and no one but them will be able to decrypt the files.</p>

<h2>Implementation Magic</h2>

<p>So, how does this work? This is the same story, but with the implementation details inserted:</p>

<ol>
<li>Alice initiates a file transfer with Bob, and enters their contact details. The web page uses Javascript or a Java applet to generate the following encryption details:

<ul>
<li>A shared prime <em>p</em> and a generator number <em>g</em>. This gets sent to the web service for storage.</li>
<li>Alice enters a secret password of her choosing, and it gets hashed into a large 128+ bit integer using something like SHA-2. This is her private key <em>a</em> (but she only needs to memorize the password).</li>
<li>In the browser, Alice&#8217;s public key, <em>A</em>, gets calculated. It equals <em>g<sup>a</sup> mod p</em>. This gets sent to the web service for storage.</li>
</ul>
</li>
<li>The web service sends out the email and text.</li>
<li>Bob gets the email and text.

<ul>
<li>He enters the secret code from the text into the web page (this will be explained later), and he&#8217;s granted access to the form.</li>
<li>He enters a secret password of his choosing, which also gets hashed just like Alice&#8217;s. This is his private key, <em>b</em>.</li>
<li>In the browser, Bob&#8217;s public key, <em>B</em>, gets calculated as <em>g<sup>b</sup> mod p</em>. This gets sent to the web service for storage.</li>
</ul>
</li>
<li>Alice receives an email saying that her file is ready for encryption and upload.

<ul>
<li>Bob&#8217;s public key is retrieved, and Alice enters her secret password. In browser, the shared secret is calculated as <em>B<sup>a</sup> mod p</em>.</li>
<li>The file is encrypted using the shared secret.</li>
</ul>
</li>
<li>Bob gets an email saying the file is ready for retrieval.

<ul>
<li>Alice&#8217;s public key is retrieved, and he enters his secret password. The shared secret is calculated from <em>A<sup>b</sup> mod p</em>.</li>
<li>In browser, the file is decrypted using the secret key, and the file is saved to disk.</li>
</ul>
</li>
</ol>


<p>Although I still find the process incredible, there&#8217;s really nothing new about the above procedure. It&#8217;s simply an implementation of the D-H exchange that hides the details from the users. What&#8217;s so neat is that the web service and anyone monitoring their communications only ever sees Bob&#8217;s public key, Alice&#8217;s public key, the generator and the prime. No one knows Bob&#8217;s secret key (including Alice!), and no one knows Alice&#8217;s (including Bob). Without these secret keys, no one, including the web service, can calculate the shared encryption key. The web service is zero-knowledge. Sort of.</p>

<h2>Stuck In The Middle</h2>

<p>The most glaring vulnerability with the D-H exchange is the possibility of a man-in-the-middle (MITM) attack. This is well documented. If Eve the eavesdropper can intercept and control Bob&#8217;s or Alice&#8217;s email channel, then Eve can sit in the middle and pretend to be both Bob and Alice. Eve can generate two shared secrets, one with Bob and one with Alice. Alice, who thinks Eve is Bob, sends the file to Eve. Eve decrypts it, reads it, then re-encrypts it using the secret she has with Bob (who thinks Eve is Alice), and sends it to Bob. The file is stolen and neither Alice nor Bob know that it happened. This raises two issues:</p>

<ol>
<li>If the email channel is insecure, Eve could steal the file.</li>
<li>If the service is evil, then the service can steal the file by doing exactly what Eve did.</li>
</ol>


<p>The first problem is solved by the text message containing the secret text code that Bob receives. In order for Bob to finish the exchange, he needs to enter the secret text code into the web page. Eve can&#8217;t do this unless she&#8217;s hijacked both his email and his phone. So, Eve can&#8217;t be the woman-in-the-middle because she can access Bob&#8217;s web page and pretend to be Bob.</p>

<p>The second one is a tough one. A potential solution is for some in-browser code to generate a hash of the public keys (<em>A</em>, and <em>B</em>). Bob and Alice could then use some out-of-band channel (perhaps over the phone) to compare the hashes. If Eve were in the middle, they&#8217;d both have a copy of Eve&#8217;s key, and the hashes wouldn&#8217;t match. The issue here is that if the site really is evil, it could simply poison the browser code to do something evil, making this whole out-of-band hash thing moot. Really, the problem is that there&#8217;s no such thing as a zero-knowledge web site. There has to be some amount of trust between the users and site. One side note is that the site does have a motivation for being honest. As long as it never sees the secret keys, it can&#8217;t be subpoenaed from anything useful (unless a judge orders it to poison its browser code).</p>

<h2>An Alternative Method</h2>

<p>Here&#8217;s an alternative method that might be simpler. It uses public key encryption:</p>

<ol>
<li>Alice initiates a file exchange by entering Bob&#8217;s email.</li>
<li>Bob gets the email, and navigates to a page that generates a key pair.

<ul>
<li>The public half of the key pair gets uploaded to the web service. He downloads the private half.</li>
</ul>
</li>
<li>Alice gets an email saying the exchange is ready.

<ul>
<li>She navigates to the site, which automatically retrieves the public key, encrypts the file, and uploads it.</li>
</ul>
</li>
<li>Bob downloads the file and decrypts it using his private key, in-browser.</li>
</ol>


<p>The advantage is that it might be simpler to implement. It&#8217;s really just a way of creating a one-time key pair, and hiding the details from the user. The disadvantage is that Bob has to hold onto a secret key, rather than a passphrase, and the same MITM vulnerability exists (although it could be fixed in a similar way).</p>

<h2>Conclusion</h2>

<p>That&#8217;s my first stab at a solution. Although I had a lot of fun dreaming it up, it&#8217;s not without its disadvantages, and open questions.</p>

<ol>
<li>The potential for MITM attacks introduces unwanted complexity (especially if you don&#8217;t trust the site). Could this be made more user friendly? Is there another solution?</li>
<li>The entire process is complex, and would probably scare off the exact people it&#8217;s trying to help. Is there an alternative method that&#8217;s simpler, but still maintains zero-knowledge?</li>
<li>Is it secure?</li>
</ol>


<p>I&#8217;d love to hear your comments on these points, or anything related.</p>

<p>Also, many thanks for <a href="http://twitter.com/Cinesias">Cinesias</a> for inspiring me to think about this, and having a bit of a brainstorming session. #FollowFriday</p>
</div>

  <footer>
    
    <p><a class="comments-link" href="/blog/blog/2011/12/16/a-zero-knowledge-file-exchange/#disqus_thread">View comments &raquo;</a></p>
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/blog/2011/08/18/search-algorithms-finding-a-bad-coin-part-ii/">Search Algorithms: Finding a Bad Coin (Part II)</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2011-08-18T13:24:00-06:00" pubdate data-updated="true">Aug 18<span>th</span>, 2011</time>
         &bull; <a rel="bookmark" href="/blog/blog/2011/08/18/search-algorithms-finding-a-bad-coin-part-ii/">&infin;</a>
      </p>
    
  </header>

<div class="entry-content"><p>In the last post, I discussed a problem about finding the bad coin in a set of 8 coins. Here, I&#8217;ll do some mathematical analysis of the different algorithms, and talk about the number of steps it takes to search through n coins using each algorithm.</p>

<h2>The Simplest Algorithm</h2>

<p>The first algorithm was the simplest, and consisted of weighing pairs of coins. We begin analyzing this algorithm by first noticing two things: (1) It could take anywhere between 1 and 4 trials to search through the 8 coins. (2) Each of these scenarios is equally likely. There&#8217;s a 1 in 4 possibility that it will be found on the first trial. Ditto for the second, third, and fourth trial. With these two pieces of information, we can calculate the average number of steps it takes to search through 8 coins. This is done by multiplying each outcome (1, 2, 3, or 4 trials) with its probability (1 in 4) and summing the values. The expected value, or average number of steps for 8 coins, is therefore 2.5.</p>

<p><img src="http://media.usrsb.in/bad-coin/avg-trials.png" alt="average trials" /></p>

<p>Another way of thinking about this goes as follows: Half the time you&#8217;ll find the coin on or before 2 trials, and half the time you&#8217;ll find the coin on or after 3 trials. Therefore, the average number of trials is 2.5.</p>

<p>That&#8217;s simple enough, but can this be generalized? Yes. For n coins, the following sum represents the average number of trials:</p>

<p><img src="http://media.usrsb.in/bad-coin/avgstepssimple.png" alt="average trials general" /></p>

<p>If you&#8217;re skeptical, try out the sum for 8 coins and verify that it produces the same equation as above. The sum simply multiplies each possible outcome (1, 2, 3, or 4 trials) by one over the total number of possible outcomes (1/4). Note that n must be an even number. If it&#8217;s not, then round up to the nearest even number.
So, what are the takeaway points?</p>

<ol>
<li>The average number of trials for n coins is proportional to n.</li>
<li>The number of trials isn&#8217;t fixed. Half the time it will take less than or equal to n/2 trials, and half the time it will take more.</li>
<li>One out of every n/2 times, it will take only 1 trial.</li>
</ol>


<p>The upshot is that the algorithm isn&#8217;t horrible for a small number of coins, but once n starts to get big, so does the number of steps required. In fact, for 8 coins, this algorithm is slightly better, on average, than the binary search, which always takes exactly 3 steps, but it&#8217;s also slightly worse than the ternary search, which always takes 2 steps. As I&#8217;ll show, this doesn&#8217;t hold when the number of coins gets larger.</p>

<h2>The Binary and Ternary Searches</h2>

<p>Calculating the average number of steps for the binary and ternary search is much easier than for the simple algorithm, because the binary and ternary search always take a fixed number of steps, as shown by the decision tree (this isn&#8217;t true if the tree is unbalanced, or if n isn&#8217;t a power of 2 or 3). We can also see that for a decision tree to search through 8 coins, it must have 8 termination points at the bottom of the tree, called &#8220;leaves.&#8221; The number of steps to complete the search is related to this by 2d≥8 for the binary tree and 3d≥8 for the ternary tree, where d is the number of steps or &#8220;depth&#8221; of the tree (Hein, p. 288). Solving for d we get an expression for the minimum number of steps, where n is the number of coins and b is 2 for a binary tree and 3 for a ternary tree:</p>

<p><img src="http://media.usrsb.in/bad-coin/treesteps.png" alt="Minimum steps to find coin" /></p>

<p>The brackets are the ceiling operator, which rounds the number up, because a tree&#8217;s depth must be an integer.</p>

<p>Hein takes this a step further and proves that the ternary decision tree is the optimal decision tree (p. 288). If there are 8 coins, there must be 8 leaves on the tree. The minimum depth for a tree with 8 leaves is 2. The tree in the last post has a depth of 2, and therefore must be an optimal tree (among others).</p>

<p>The takeaway points here are:</p>

<ol>
<li>The ternary and binary searches take a fixed number of steps (for a balanced tree where n is a power of 2 or 3)</li>
<li>The number of steps for n coins is proportional to logb(n).</li>
<li>The ternary and binary searches scale much better than the simple algorithm. See the table below:</li>
</ol>


<table>
<tr><td>n</td><td>Simple Algorithm</td><td>Binary</td><td>Ternary</td></tr>
<tr><td>8</td><td>2.5</td><td>3</td><td>2</td></tr>
<tr><td>128</td><td>32.5</td><td>7</td><td>5</td></tr>
<tr><td>1024</td><td>256.5</td><td>10</td><td>7</td></tr>
<tr><td>1,048,576</td><td>262,144.5</td><td>20</td><td>13</td></tr>
</table>


<p>As Jon Bentley points out in <a href="http://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880">Programming Pearls</a> [Amazon.com], because the ternary search scales so much better, there&#8217;s some sufficiently large value of n, at which a pocket calculator running the ternary search will outpace a supercomputer running the simple algorithm.</p>
</div>

  <footer>
    
    <p><a class="comments-link" href="/blog/blog/2011/08/18/search-algorithms-finding-a-bad-coin-part-ii/#disqus_thread">View comments &raquo;</a></p>
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/blog/2011/08/17/a-search-algorithm-puzzle-finding-a-bad-coin/">A Search Algorithm Puzzle: Finding a Bad Coin</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2011-08-17T13:30:00-06:00" pubdate data-updated="true">Aug 17<span>th</span>, 2011</time>
         &bull; <a rel="bookmark" href="/blog/blog/2011/08/17/a-search-algorithm-puzzle-finding-a-bad-coin/">&infin;</a>
      </p>
    
  </header>

<div class="entry-content"><p>Today I have a puzzle for you from James Hein&#8217;s textbook, <a href="http://www.amazon.com/Discrete-Structures-Logic-Computability-James/dp/0763772062">Discrete Structures, Logic, and Computability</a>. It&#8217;s a question about finding a &#8220;bad coin&#8221; and goes as follows:</p>

<blockquote><p>Suppose we are asked to use a pan balance to find the heavy coin among eight coins with the assumption that they all look alike and the other seven all have the same weight. (p. 287)
So, the problem is that we have 8 coins, and one of them is a bad coin that weighs more than the others. With only a pan balance, what&#8217;s the most efficient way to find the bad coin?</p></blockquote>

<p>The simplest solution is to just weigh the coins in pairs. Grab a pair of coins and put one coin on each side of the balance. If one is heavier, you&#8217;ve found the bad coin and you can stop. If they weigh the same, move on to the next pair. At most, this will take 4 trials, but is this optimal? No. As James Hein points out, we can do better.</p>

<p>The better solution is to put 4 of the coins on one side of the balance, and the other 4 coins on the other side of the balance. One side must be heavier than the other, because one side must contain the heavier coin. If the left side is heavier, then we discard the lighter coins on the right side. We then split the remaining coins into 2 groups of 2, and repeat the procedure by weighing one group against the other. The heavier of the two pairs then gets split and weighed. The coin that is heavier is the bad coin. This is a sure way to find the bad coin in 3 steps.</p>

<p>Programmers will recognize this algorithm as a binary search, which can be represented by the following decision tree from page 287 of Hein&#8217;s book:</p>

<p><img src="http://media.usrsb.in/bad-coin/dectree.png" alt="Binary Search Tree" /></p>

<p>First we weigh 1 through 4 against 5 through 8. If 1 through 4 is heavier, then we weigh 1 and 2 against 3 and 4 and so on until we reach the bottom of the tree. It&#8217;s a neat solution that has lots of uses. The obvious application for this is searching through lots of data, but an especially cool use is the <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Huffman_coding">Huffman coding algorithm</a>. A variation on Huffman coding is how zip archives are compressed.</p>

<p>But wait a minute. We can do one better by allowing some decision points (nodes) on the tree to have three connections rather than two, making it a ternary tree. See the revised, and optimal, decision tree below (Hein, p. 288):</p>

<p><img src="http://media.usrsb.in/bad-coin/ternary.png" alt="Optimal Decision Tree" /></p>

<p>For this revised procedure, we begin by weighing 1 through 3 and 4 through 6. If those groups have equal weight, then we go down the middle branch and see that the bad coin must be 7 or 8. We follow a similar procedure if, after the first weighing, 1 through 3 is heavier. We go down the left branch and test 1 and 2. If those weigh the same, then the bad coin must be coin 3. Pretty clever.</p>

<p>Next post I&#8217;ll attempt some mathematical analysis on the algorithms, and see what we can say about how many steps it takes to sort through n coins. In the meantime, check out this <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Binary_search_algorithm#Computer_use">interesting tidbit from Wikipedia&#8217;s Binary Search article</a>. Despite its ubiquity and seeming simplicity, it&#8217;s apparently quite difficult to implement!</p>
</div>

  <footer>
    
    <p><a class="comments-link" href="/blog/blog/2011/08/17/a-search-algorithm-puzzle-finding-a-bad-coin/#disqus_thread">View comments &raquo;</a></p>
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/blog/2011/08/15/a-database-engine-in-16-lines/">A Database Engine in 16 Lines</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2011-08-15T13:36:00-06:00" pubdate data-updated="true">Aug 15<span>th</span>, 2011</time>
         &bull; <a rel="bookmark" href="/blog/blog/2011/08/15/a-database-engine-in-16-lines/">&infin;</a>
      </p>
    
  </header>

<div class="entry-content"><p>Recently I&#8217;ve been playing around with a neat command line utility called netcat. It makes it incredibly easy to add networking functionality to your scripts. What it does is allow you to open a port on your machine and listen for incoming connections. Should a connection occur, anything the remote machine sends is dumped to stdout, and anything written to stdin is sent out to the remote machine. As a demo, I decided to write a database engine with it, and I managed to do it in 16 lines.</p>

<pre><code>#!/bin/bash

PORT=1234
DATA_FILE="/full/path/to/data"

listen () {
    TIMEOUT=10
    echo "$2" | nc -l -p $1 -w $TIMEOUT -q 0 
}

while :; do
    ANSWER_PORT=$((RANDOM % 1000 + 1028))
    QUERY="$(echo $ANSWER_PORT | nc -l -p $PORT -q 2)"
    ANSWER="$(grep "^$QUERY," "$DATA_FILE" | sed "s/ $QUERY, //")"
    listen "$ANSWER_PORT" "$ANSWER" &amp;
done
</code></pre>

<p>The database itself is simply a text file full of key-value pairs. So, a remote machine can send over a key, and the database responds with that key&#8217;s corresponding value. If, for example, the database was full of names (keys) and phone numbers (values), a remote machine could send over someone&#8217;s name, and the database would respond with that person&#8217;s phone number. Not bad for 16 lines.</p>

<p>Before I step through the code, I&#8217;ll explain its overall functionality. When first executed, the script opens up port 1234 and listens. When a remote machine wants to query it, the remote machine connects to port 1234 and sends over its query (a key). The script receives this and, over the same connection, sends back a random number between 1028 and 2028. Suppose the random number is 1050. The database will then open up port 1050, and when the remote machine connect to that port, the database will send its answer over that connection (the value corresponding to the key), and the transaction is finished. Let&#8217;s look at the code now.</p>

<h2>Analysis</h2>

<p>The script starts off with two variables. The first is the port that the script listens on for incoming queries. The second points to the text file containing the key-value pairs. The file would look something like this:</p>

<pre><code>alex beal, 555-555-5555
bob, 111-111-1111
joe, 222-222-2222
</code></pre>

<p>Where, &#8220;alex beal&#8221;, &#8220;bob&#8221;, and &#8220;joe&#8221; are the keys, and the values corresponding to those keys are listed after the comma. Let&#8217;s skip over the listen function for now and examine the while loop below it.</p>

<pre><code>while :; do
    ANSWER_PORT=$((RANDOM % 1000 + 1028))
    QUERY="$(echo $ANSWER_PORT | nc -l -p $PORT -q 2)"
    ANSWER="$(grep "^$QUERY," "$DATA_FILE" | sed "s/^$QUERY, //")" 
    listen "$ANSWER_PORT" "$ANSWER" &amp;
done
</code></pre>

<p>The first line is a while loop that continues forever until the script receives an interrupt. The second two lines get a random number between 1028 and 2028 and store it to <code>$ANSWER_PORT</code>. That value is piped into the netcat instance on the third line, which listens for connections (<code>-l</code>) on port 1234 (<code>-p $PORT</code>). Once a connection is established, and the random port number is sent, the remote host has 2 seconds to send over a query (<code>-q 2</code>), which gets stored to <code>$QUERY</code>. This means that after the first two lines have executed, the query is received, and the random answer port is sent.</p>

<p>The next lines search through the database file for the key-value pair. Searching the database is as simple as <code>grep</code>-ing the data file for the line beginning with the key, and stripping that key from the output with sed.</p>

<p>Finally we call the <code>listen</code> function defined above. This is passed the port that the client must connect to to receive the answer (<code>$ANSWER_PORT</code>), and the answer itself (<code>$ANSWER</code>).</p>

<pre><code>listen () {
    TIMEOUT=10
    echo "$2" | nc -l -p $1 -w $TIMEOUT -q 0 
}
</code></pre>

<p>The answer, which is the second argument (<code>$2</code>), is piped into netcat (<code>nc</code>). The flags tell it to listen (<code>-l</code>) on the port passed to it as the first argument (<code>-p $1</code>). The netcat instance will stop listening after <code>$TIMEOUT</code> seconds, and after the answer is sent, it will close immediately (<code>-q 0</code>). As you can see, the listen function is called as a background process, so the loop can continue back to the top, allowing other requests to be handled while the answer is sent to the client in the background.</p>

<h2>The Client&#8217;s Script</h2>

<p>You can query it remotely with this script:</p>

<pre><code>#!/bin/bash
ANSWERPORT=$(echo "$2" | nc $1 1234)
sleep 1s
nc $1 $ANSWERPORT
</code></pre>

<p>The first line both receives the answer port, and sends over the query. The script then sleeps for 1 second, while the database handles the request. Finally, it connects a second time to retrieve its answer. The script is used as follows:</p>

<pre><code>query.sh REMOTE_IP QUERY_STRING
</code></pre>

<h2>Conclusion</h2>

<p>Although this was a fun exercise, the script itself isn&#8217;t very practical. It&#8217;s slow (at least compared to MySQL), and probably insecure, but there might be a use for it on a private network with trusted users. The take away points here are the different netcat constructs that you could apply to your own programs, such as sending and receiving at the same time, and setting up a client-server model. Definitely let me know in the comments if you end up making something cool!</p>

<p><a href="http://media.usrsb.in/db/db-scripts.zip">Download the scripts.</a></p>
</div>

  <footer>
    
    <p><a class="comments-link" href="/blog/blog/2011/08/15/a-database-engine-in-16-lines/#disqus_thread">View comments &raquo;</a></p>
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/blog/2011/08/13/secure-versioned-remote-backups-with-rdiff-backup/">Secure Versioned Remote Backups With Rdiff-Backup</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2011-08-13T14:31:00-06:00" pubdate data-updated="true">Aug 13<span>th</span>, 2011</time>
         &bull; <a rel="bookmark" href="/blog/blog/2011/08/13/secure-versioned-remote-backups-with-rdiff-backup/">&infin;</a>
      </p>
    
  </header>

<div class="entry-content"><p>When putting together a backup solution for this web server, I was looking for a few things:</p>

<ol>
<li><strong>Simplicity:</strong> The less new software, the better. Rsync is both powerful and complex, and I wanted to avoid it. Other things being equal, simple solutions are also more reliable.</li>
<li><strong>Security:</strong> I needed to prevent an attacker who gained access to my web server from also gaining access to my backup server. Backing up over an encrypted connection was also a necessity.</li>
<li><strong>Versioning:</strong> I needed my solution to keep several versions of all my files. A solution that only keeps the most recent version of a file is useless, if that version turns out to be corrupted.</li>
<li><strong>Incrementing:</strong> An efficient backup solution should only update the files that have changed. This ruled out simply tar-ing and ssh-ing my entire webroot over to my backup server.</li>
<li><strong>Automation:</strong> This solution should automatically run as a cron job.</li>
</ol>


<p>As you can see, some of these goals conflict. Wanting versioned incremental backups, while also ruling out rsync just made my life harder. Automation and security also butt heads. If my web server can access my backup server without a password, how can I prevent an attacker who&#8217;s taken over my web server from trashing my backups? As I&#8217;ll show, I managed to piece this together with only one new software package: rdiff-backup. This took care of versioning and incrementing in a simpler way than rsync would have. The rest was achieved with tools installed on every web server: ssh and cron.</p>

<h2>Backing up with rdiff-backup</h2>

<p>Let&#8217;s start with rdiff-backup. This is dead simple. On Ubuntu, installing is only an apt-get away. This needs to be done on the web server and backup server:</p>

<pre><code>sudo apt-get install rdiff-backup
</code></pre>

<p>Backing up to a remote directory over ssh isn&#8217;t much harder:</p>

<pre><code>rdiff-backup /var/www backups@example.com::/var/backups
</code></pre>

<p>That will backup the local directory <code>/var/www</code> to <code>/var/backups</code> on <code>example.com</code> using the ssh user <code>backups</code>. It&#8217;s that simple. rdiff-backup handles the versioning and incrementing automatically. Also, since it&#8217;s done over ssh, everything is encrypted.
Restoring is just as easy:</p>

<pre><code>rdiff-backup -r 3D backups@example.com::/var/backups/www /var/www.old
</code></pre>

<p>That will copy whatever you backed up to <code>/var/backups/www</code> three days prior to <code>/var/www.old</code> on the local machine. Hopefully by now you see why I love this utility. It&#8217;s basically rsync, but stripped down and rebuilt specifically for backups. Best of all, there are no config files or servers to maintain.</p>

<h2>Automation with cron</h2>

<p>So, those are the basics of rdiff-backup. How do we automate this? Here&#8217;s the backup script that I use on this web server:</p>

<pre><code>#!/bin/bash

RDIFF="/usr/bin/rdiff-backup"
REMOTE="backups@example.com::/home/backups/newest/"
CONF="/etc/backups"

cat $CONF | while read DIR; do
        $RDIFF $DIR $REMOTE$(basename $DIR)
        if [ $? != 0 ]; then
                echo "Exited with errors. Backup process stopped at $DIR"
                exit 1;
        fi
done
</code></pre>

<p>What this does is read the paths I&#8217;ve listed in the text file <code>/etc/backups</code>, and backs those up to <code>/home/backups/newest</code> on the machine <code>example.com</code> with the user <code>backups</code>. So if <code>/etc/backups</code> looks like this:</p>

<pre><code>/etc/
/home/alex/
/var/www/
</code></pre>

<p>Then all those directories get backed up to the remote machine. The first time it&#8217;s run, it simply mirrors the directories to the remote machine. Each consecutive execution only copies the changed files over. Versioning is, of course, handled automatically by rdiff-backup.</p>

<p>I wrote the script to be easily customizable. Change <code>$REMOTE</code> to modify which machine, user, and directory the files are backed up to. Change <code>$CONF</code> to modify which file contains all the paths to be backed up. <code>$RDIFF</code> simply points to wherever the rdiff-backup binary is (well, python script, actually). As it&#8217;s currently set, <code>$RDIFF</code> should work on Ubuntu 10.04 machines.</p>

<p>To automate this, simply set it as a cron job on the web server, and run it hourly or daily. Make sure the user running the job has high enough privileges to access the files you want to back up (unless you want to set up some complex permissions, simply running this as root is an unfortunate necessity).</p>

<p>Finally, on the remote machine, you may want some sort of script that manages the backup directory. One idea would be to have the backup directory tar-ed and compressed, then saved somewhere safe. Once that&#8217;s done, the directory could be cleared out, so the next time the backup script runs, a fresh copy of all the files would be copied over. Set this to run once a week and you&#8217;ll have weekly full backups, with nightly (or hourly) incremental backups. The following script will do that for you:</p>

<pre><code>#!/bin/bash

NEW="/home/backups/newest"
OLD="/home/backups/archive"

# Tar and compress the old files
(
    cd `dirname $NEW`
    tar -zcf "$OLD/`date "+%F-%H%M"`.tar.gz" "`basename "$NEW"`"
)

# Clear out the backup directory
if [ $? == 0 ]; then
    rm -rf "$NEW"
    mkdir "$NEW"
else
    echo "Exited with errors. Nothing was deleted, but the files may not have been rotated."
    exit 1
fi
</code></pre>

<p><code>$NEW</code> is the location of your newest backups. <code>$OLD</code> is where you want the tar-ed and compressed copies stored.</p>

<h2>Security with ssh</h2>

<p>We&#8217;re almost there. Rdiff-backup is installed, and the scripts are automatically backing up and rotating our backup files. The only problem is that every time the script connects to the backup server, it&#8217;s asked for a password (the remote user&#8217;s ssh password). We can&#8217;t be there to type it in, so how do we deal with this? The solution is to create a public/private key pair that the script can log in with. There are lots of places on the web that have detailed instructions on how to do this, but I&#8217;ll run through it quickly.</p>

<p>First we decide which user is running the backup script on our web server. If it&#8217;s root, then we log in as root and run <code>ssh-keygen</code>. When prompted for a password, leave it blank. After this is done, we need to copy the public key located under <code>/root/.ssh/id_rsa.pub</code> to the remote machine. If we&#8217;re logging in as backups on the remote machine, then we copy the public key into the <code>/home/backups/.ssh</code> directory (create the <code>.ssh</code> directory if it doesn&#8217;t already exist) and rename the file <code>authorized_keys</code>. Now when root connects over ssh to the backup server, he won&#8217;t be prompted for a password, and neither will the backup script being run as a root cron job. Ahhh the magic of public key cryptography.</p>

<p>The obvious problem here is that if an attacker gets root on the web server, he has access to the backup server. Lucky for us, ssh has a built in way of restricting a remote user to only one command. We do this by prefixing the public key with <code>command="RESTRICTED_COMMAND"</code>. So, for example, we can restrict a remote user to rdiff-backup by modifying the <code>authorized_keys</code> file to look something like this:</p>

<pre><code>command="rdiff-backup --server --restrict-update-only /home/backups/newest/" ssh-rsa AAB3NzaC1 [...]
</code></pre>

<p>That allows a remote user to only execute rdiff-backup in server mode. But notice the second flag <code>--restrict-update-only</code>. That restricts the user to the backup directory, and only allows her to update the backups, and not delete or otherwise trash them. Pretty cool. The worst an attacker could do is fill the backup server&#8217;s hard drive by pushing a huge amount of data to it, but since rdiff-backup is versioned, no old versions of the files will be lost.</p>

<p>Also, there are additional options you can prefix to the public key to lock down the server even more. Check out the <code>ssh-keygen</code> man pages, and look under the <code>-O</code> flag.</p>

<h2>Conclusion</h2>

<p>So, that&#8217;s my custom built backup solution. I realize I glazed over a lot of small details, and this isn&#8217;t really a step by step how-to (e.g., I never explained how to set up a cron job). I leave it as an exercise to the reader to put it all together. To help you, I&#8217;ve included the scripts at the bottom of this post. I also check the comments obsessively, so please don&#8217;t hesitate to ask if you have any questions.</p>

<p><a href="http://media.usrsb.in/rdiff-backup/backup.zip">Download the scripts.</a></p>
</div>

  <footer>
    
    <p><a class="comments-link" href="/blog/blog/2011/08/13/secure-versioned-remote-backups-with-rdiff-backup/#disqus_thread">View comments &raquo;</a></p>
    
    
  </footer>


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/blog/page/4/">&larr; Older</a>
    
    <a href="/blog/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/blog/page/2/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/blog/2012/05/20/did-the-boulder-pd-reduce-traffic-accidents/">Did the Boulder PD Reduce Traffic Accidents?</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2012/05/05/permutations-an-interview-question/">Permutations: An Interview Question</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2012/04/07/look-ma-no-loops/">Look, Ma! No Loops: Reversing Word Order</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2012/04/01/building-data-structures-from-functions/">Building Data Structures from Functions</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2012/02/05/super-bowl-probabilities/">Super Bowl Probabilities: The Coin Toss</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/beala">@beala</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'beala',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/blog/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("beala", 4, false);
    });
  </script>
  <script src="/blog/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/beala" class="twitter-follow-button" data-show-count="false">Follow @beala</a>
  
</section>


<section>
  <h1>My Pinboard</h1>
  <ul id="pinboard_linkroll">Fetching linkroll&#8230;</ul>
  <p><a href="http://pinboard.in/u:beala">My Pinboard Bookmarks &raquo;</a></p>
</section>
<script type="text/javascript">
  var linkroll = 'pinboard_linkroll'; //id target for pinboard list
  var pinboard_user = "beala"; //id target for pinboard list
  var pinboard_count = 3; //id target for pinboard list
  (function(){
    var pinboardInit = document.createElement('script');
    pinboardInit.type = 'text/javascript';
    pinboardInit.async = true;
    pinboardInit.src = '/javascripts/pinboard.js';
    document.getElementsByTagName('head')[0].appendChild(pinboardInit);
  })();
</script>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Alex Beal -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'usrsbin';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
