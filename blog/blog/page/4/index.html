
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>/usr/sbin/blog</title>
  <meta name="author" content="Alex Beal">

  
  <meta name="description" content="Here&#8217;s a math problem that surprised me: Imagine a sphere of diameter d intersected by two parallel planes a distance h apart. What do you &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://usrsb.in/blog/blog/page/4">
  <link href="/blog/favicon.png" rel="icon">
  <link href="/blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/blog/javascripts/modernizr-2.0.js"></script>
  <script src="/blog/javascripts/ender.js"></script>
  <script src="/blog/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/blog/atom.xml" rel="alternate" title="/usr/sbin/blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-27836693-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/blog/">/usr/sbin/blog</a></h1>
  
    <h2>Alex's Geekery Journal.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/blog/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:usrsb.in/blog" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="http://usrsb.in">Home</a></li>
  <li><a href="/blog/">Blog</a></li>
  <li><a href="/blog/tools">Tools</a></li>
  <li><a href="/blog/about">About</a></li>
  <li><a href="/blog/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/blog/2011/08/11/the-surface-area-of-a-sphere-between-parallel-planes/">The Surface Area of a Sphere Between Parallel Planes</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2011-08-11T15:49:00-06:00" pubdate data-updated="true">Aug 11<span>th</span>, 2011</time>
         &bull; <a rel="bookmark" href="/blog/blog/2011/08/11/the-surface-area-of-a-sphere-between-parallel-planes/">&infin;</a>
      </p>
    
  </header>

<div class="entry-content"><p>Here&#8217;s a math problem that surprised me: Imagine a sphere of diameter <em>d</em> intersected by two parallel planes a distance <em>h</em> apart. What do you think the surface area of the section of the sphere between the planes is? You&#8217;re first thought might be that there&#8217;s not enough information. The area will depend upon what part of the sphere the planes intersect. If the planes cut out the middle third of the sphere, that will be a different surface area compared to if the planes cut out the left third or the right third.</p>

<p>That was my first thought, at least, and, as it turns out, it&#8217;s wrong. <strong>The area only depends on the distance between the planes, and the diameter of the sphere. It doesn&#8217;t matter where these planes are in relation to the sphere.</strong> As long as they both intersect the sphere, the surface area will equal <em>πdh</em>, where d is the diameter and <em>h</em> is the distance between the planes. Don&#8217;t believe me? Here&#8217;s the math to prove it:</p>

<p>First we begin with the formula for the surface area of a function rotated around the x axis from <em>a</em> to <em>b</em>. If you want an explanation of this equation, the section of my textbook that covers this is actually <a href="http://www.stewartcalculus.com/data/ESSENTIAL%20CALCULUS/upfiles/topics/ess_at_06_asr_stu.pdf">posted online [PDF]</a> by the publishers (also note that this is problem 32 from that chapter).</p>

<p><img src="http://media.usrsb.in/sa-sphere/1.png" alt="Suface Area Formula" /></p>

<p>Since we are finding the surface area of a sphere, we need the function for a circle, which we will rotate around the x axis, thus producing our sphere. If we can remember back to high school geometry, we&#8217;ll know that the equation for a sphere is <em>x2+y2=r2</em>. We now solve for <em>y</em>, and plug it in for <em>f(x)</em>, and also find the derivative of <em>f(x)</em> and plug it in for <em>f&#8217;(x)</em>:</p>

<p><img src="http://media.usrsb.in/sa-sphere/2.png" alt="title" /></p>

<p>We now simplify the integral:</p>

<p><img src="http://media.usrsb.in/sa-sphere/3.png" alt="title" /></p>

<p><em>f(x)</em> is moved into the square root:</p>

<p><img src="http://media.usrsb.in/sa-sphere/4.png" alt="title" /></p>

<p>We distribute:</p>

<p><img src="http://media.usrsb.in/sa-sphere/5.png" alt="title" /></p>

<p>More simplification:</p>

<p><img src="http://media.usrsb.in/sa-sphere/6.png" alt="title" /></p>

<p><img src="http://media.usrsb.in/sa-sphere/7.png" alt="title" /></p>

<p>We now integrate:</p>

<p><img src="http://media.usrsb.in/sa-sphere/8.png" alt="title" /></p>

<p><img src="http://media.usrsb.in/sa-sphere/9.png" alt="title" /></p>

<p><img src="http://media.usrsb.in/sa-sphere/10.png" alt="title" /></p>

<p><em>b-a</em> is simply the distance between the two planes, which we call <em>h</em>:</p>

<p><img src="http://media.usrsb.in/sa-sphere/11.png" alt="title" /></p>

<p>2r is the diameter of the sphere, which we call d:</p>

<p><img src="http://media.usrsb.in/sa-sphere/12.png" alt="title" /></p>

<p>There you have it. The surface area of a sphere between two parallel planes is equal to <em>πdh</em>. It doesn&#8217;t matter where these planes are in relation to the sphere. All that matters is that both planes intersect the sphere. Cool, huh? No? Ok, fine. Well, I thought it was interesting.</p>
</div>

  <footer>
    
    <p><a class="comments-link" href="/blog/blog/2011/08/11/the-surface-area-of-a-sphere-between-parallel-planes/#disqus_thread">View comments &raquo;</a></p>
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/blog/2011/08/06/copying-strings-in-one-line-c-programming/">Copying Strings in One Line (C Programming)</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2011-08-06T16:01:00-06:00" pubdate data-updated="true">Aug 6<span>th</span>, 2011</time>
         &bull; <a rel="bookmark" href="/blog/blog/2011/08/06/copying-strings-in-one-line-c-programming/">&infin;</a>
      </p>
    
  </header>

<div class="entry-content"><p>Here&#8217;s a quickie for your Saturday afternoon:</p>

<pre><code>strcpy(s, t)    /* copy t to s; pointer version 3 */
char *s, *t;
{
    while(*s++ = *t++)
        ;
}
</code></pre>

<p>That&#8217;s a classic one from the <a href="http://en.wikipedia.org/wiki/The_c_programming_language">K&amp;R text</a> (page 101). You can tell how old it is by the style of the function declaration. There&#8217;s no return type (so it defaults to <code>int</code>, even though nothing is actually returned), and the types of the arguments are declared on a separate line. Although it&#8217;s far from obvious, what the function does is copy the string <code>t</code> to the string <code>s</code>.</p>

<p>Anyway, as you can see, order of operations is key. Dereferencing precedes assignment, assignment precedes evaluation, and evaluation precedes increment. Here&#8217;s what happens:</p>

<ol>
<li>The current position of <code>s</code> and <code>t</code> are dereferenced, and the character at that position is fetched.</li>
<li>That character is copied from <code>t</code> to <code>s</code></li>
<li>The character just copied gets evaluated. The loop terminates if it&#8217;s the null character, &#8216;\0&#8217;.</li>
<li>The pointers are incremented to the next character in the string.</li>
<li>The loop repeats, copying the consecutive characters, including the null character.</li>
</ol>


<p>It&#8217;s definitely a cool academic exercise, but it&#8217;s so obfuscated, that even the order of operations table in the K&amp;R book is of no help. It lists <code>++</code> and <code>*</code> as having the same precedence. To see what&#8217;s going on here, we need to go to the C99 spec:</p>

<blockquote><p>The result of the postfix <code>++</code> operator is the value of the operand. After the result is obtained, the value of the operand is incremented. (page 75)</p></blockquote>

<p>It&#8217;s definitely a bit of black magic. Use this code wisely.</p>
</div>

  <footer>
    
    <p><a class="comments-link" href="/blog/blog/2011/08/06/copying-strings-in-one-line-c-programming/#disqus_thread">View comments &raquo;</a></p>
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/blog/2011/08/05/1-minus-1-equals-what-fun-with-sums-and-limits/">1 Minus 1 Equals What? (Fun With Sums and Limits)</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2011-08-05T16:10:00-06:00" pubdate data-updated="true">Aug 5<span>th</span>, 2011</time>
         &bull; <a rel="bookmark" href="/blog/blog/2011/08/05/1-minus-1-equals-what-fun-with-sums-and-limits/">&infin;</a>
      </p>
    
  </header>

<div class="entry-content"><p>Here&#8217;s a cool problem I came across when reviewing for one of my calculus exams:</p>

<p><img src="http://media.usrsb.in/sum-paradox/question.png" alt="The Question" /></p>

<p>You begin with the numbers 0 through 1. Every iteration removes 1/3 from the remaining segments. As stated above, the expression for the total amount removed after m iterations is:</p>

<p><img src="http://media.usrsb.in/sum-paradox/sum.png" alt="title" /></p>

<p>The first iteration removes 1/3. The second removes 1/3 from the remaining two segments. The remaining segments are 1/3 long, and 1/3 of that is 1/9. We do that once for each remaining segment, so 2/9 is removed. And so on.</p>

<p><img src="http://media.usrsb.in/sum-paradox/sum2.png" alt="title" /></p>

<p>What if we iterate an infinite number of times? Then we have a convergent geometric series. Finding the sum is easy:</p>

<p><img src="http://media.usrsb.in/sum-paradox/sol.png" alt="title" /></p>

<p>So, what&#8217;s the total amount or length of numbers removed? 1. That&#8217;s the entire length. It seems like we&#8217;ve removed the entire segment. But wait a minute. If we look at the image of the original question above, we see that after every iteration, there are 2<sup>n+1</sup> segments remaining. When n=0, there are 2 segments. When n=1, there are 4 segments, etc. As we remove more and more, 2<sup>n+1</sup> approaches infinity. In other words, the limit does not exist, and the number of segments goes to infinity.</p>

<p><img src="http://media.usrsb.in/sum-paradox/limit-dne.png" alt="title" /></p>

<p><strong>So, even though we&#8217;ve seemingly removed the entire length, there are an infinite number of segments remaining.</strong> That&#8217;s weird.</p>

<p>Hopefully by now I have you a bit puzzled. This is the point in the post where I&#8217;m supposed to resolve the paradox. I have bad news, though: I don&#8217;t have much for you. I&#8217;m definitely not a mathematician (I just play one on the internets), but if I had to speculate, I&#8217;d say there are two things going on here:</p>

<ol>
<li>Limits!</li>
<li>We&#8217;re taking the math too literally.</li>
</ol>


<p>What I mean by that is, (1) as we&#8217;ve learned from limits, an infinite number of really small things (in this case, segments) can add to a finite number. This doesn&#8217;t quite resolve the paradox though. Usually an infinite number of small things adds to something greater than 0. Here it looks like all the segments add to nothing. There are an infinite number of segments, but we still have nothing left. Hopefully this is where point (2) saves the day.</p>

<p>We&#8217;re taking the math too literally. When we take this sum to infinity, what we&#8217;re really saying is that as we get closer and closer to infinity, we&#8217;re getting closer and closer to removing a length of 1, <em>but we never actually get there.</em> Similarly, when we take the limit, what we&#8217;re really saying is that as we remove more and more segments, we get closer and closer to having an infinite number of segments left over, <em>but we never actually get there either.</em> <strong>As long as we never actually get to either of these points, we haven&#8217;t contradicted ourselves.</strong> I think. If you have a deeper insight into this, definitely be sure to post it in the comments!</p>
</div>

  <footer>
    
    <p><a class="comments-link" href="/blog/blog/2011/08/05/1-minus-1-equals-what-fun-with-sums-and-limits/#disqus_thread">View comments &raquo;</a></p>
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/blog/2011/08/04/how-old-school-c-programmers-process-arguments/">How Old School C Programmers Process Arguments</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2011-08-04T16:39:00-06:00" pubdate data-updated="true">Aug 4<span>th</span>, 2011</time>
         &bull; <a rel="bookmark" href="/blog/blog/2011/08/04/how-old-school-c-programmers-process-arguments/">&infin;</a>
      </p>
    
  </header>

<div class="entry-content"><p>Here&#8217;s a bit of code from Kernighan&#8217;s and Ritchie&#8217;s seminal text, <a href="http://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628">The C Programming Language</a>. I&#8217;m not sure I&#8217;d actually recommend coding this way (as written in the book, the entire program has only one comment), but it&#8217;s so darn clever and concise, I can&#8217;t help but post it. This snippet is part of a larger program called <code>find</code> that searches text for patterns, but the details aren&#8217;t important. I want to focus on the portion below that parses the arguments passed to the program. Don&#8217;t worry about understanding it just yet. I&#8217;ll step through it below:</p>

<pre><code>char *s;
while (--argc &gt; 0 &amp;&amp; (*++argv)[0] == '-')
    for(s = argv[0]+1; *s != '\0'; s++)
        switch(*s) {
            case 'x':
                /* Set appropriate flags for 'x' option */
                break;
            case 'n':
                /* Set appropriate flags for 'n' option */
                break;
            default:
                printf("Illegal option %c\n", *s);
                argc = 0;
                break;
        }
if( argc != 1)
    printf("Usage: find -x -n pattern\n");
else
    /* Main program logic goes here */
</code></pre>

<p>What&#8217;s so cool about this is its flexibility. Those two nested loops can process all of the following (and more):</p>

<pre><code>find -xn hello
find -nx hello
find -x -n hello
find -n -x hello
find hello
find -x hello
...
</code></pre>

<p>As you can see, the usage is <code>find [-x] [-n] PATTERN</code>. The nested loops above process the flags, <code>-x</code> and <code>-n</code>, in any order, and either separated or concatenated. Hopefully you&#8217;re as impressed as I was.
Anyway, let&#8217;s dive into the code and begin by looking at the while statement.</p>

<h2>The while Loop</h2>

<pre><code>while (--argc &gt; 0 &amp;&amp; (*++argv)[0] == '-')
</code></pre>

<p>What&#8217;s going on here? First, the while loop decrements <code>argc</code> and checks that it&#8217;s greater than 0 (as dictated by convention, <code>argc</code> holds the number of arguments passed to the program). Whenever a flag is processed, <code>argc</code> is decremented, thus making it a running count of how many flags there are left to process. If it&#8217;s 0, then there&#8217;s nothing left to do. Notice that the decrement always occurs before the &#8216;>&#8217; is evaluated. This would be true even if it were postfix (i.e., <code>argc-- &gt; 0</code>).</p>

<p>If argc checks out, then we move on to <code>(*++argv)[0]=='-'</code>. Yikes. That&#8217;s a doozy. First remember that <code>argv</code> is a pointer to the strings that contain the arguments. So, <code>argv</code> points to the string containing the program name and <code>(argv+1)</code> points to the string containing the first argument. That means that <code>(*argv)[0]</code> is the first character of the program name and <code>(*argv)[1]</code> is the first character of the first argument. Putting that together, <code>(*++argv)[0]</code> increments <code>argv</code>, dereferences it to a string, and then gets the first character of that string. In other words, if <code>argv</code> was originally pointing to the string containing the program&#8217;s name, it&#8217;s now pointing to the string containing the first argument, and then grabbing the first character of that string and comparing it to &#8216;-&#8216;. Why&#8217;s it doing that? Because it wants to make sure it&#8217;s looking at a string containing a flag, and flags begin with the &#8216;-&#8217; character.</p>

<p>Extra Credit: How is <code>*++argv[0] == '-'</code> different than <code>(*++argv)[0] == '-'</code>?</p>

<p>By the end of all of this, <code>argc</code> represents the number of arguments remaining and <code>argv</code> is pointing to the string containing the first argument. Wow.</p>

<p>That was a bit of a slog, but we&#8217;re not done yet. Let&#8217;s look at the for loop.</p>

<h2>The for Loop</h2>

<pre><code>char *s;
for(s = argv[0]+1; *s != '\0'; s++)
</code></pre>

<p>Oh boy. More pointer arithmetic on arrays of arrays. Well, what&#8217;s going on here? Remember that now <code>argv</code> is pointing to the string containing the first argument. Therefore, <code>argv[0]</code> is the pointer to the first character of that string and <code>argv[0]+1</code> is the pointer to the second character of that string. <code>argv[0]+1</code> is then assigned to <code>s</code>. The result is that, if <code>argv</code> was pointing to &#8220;-xn&#8221;, then s is now pointing to the &#8220;x&#8221; in that string.
Lucky for us, the last half is much simpler. <code>*s != '\0'</code> checks to make sure that it hasn&#8217;t reached the end of the string yet, and <code>s++</code> increments the pointer (after the loop has finished its first run, of course). If the first run processed the &#8220;x&#8221; in &#8220;-xn&#8221;, then <code>s</code> is incremented and the &#8220;n&#8221; is processed. The third iterations sees the &#8220;\0&#8221; at the end of the string and exits. So, to bring this all together, the for loop traverses concatenated flags (i.e., it moves the pointer from the &#8220;x&#8221; to the &#8220;n&#8221; in &#8220;-xn&#8221;) and the while loop traverses separated flags (i.e., it moves the pointer from the &#8220;-x&#8221; to the &#8220;-n&#8221; in &#8220;-x -n&#8221;).</p>

<h1>The switch Statement</h1>

<pre><code>switch(*s) {
      case 'x':
        /* Set appropriate flags for 'x' option */
        break;
    case 'n':
         /* Set appropriate flags for 'n' option */
        break;
    default:
        printf("Illegal option %c\n", *s);
        argc = 0;
        break;
}
</code></pre>

<p>The switch is simple enough. It tests if <code>*s</code> is equal to one of the flags, and then does the necessary processing for that flag. Most likely it just sets an internal flag, which will be taken into account when the main part of the program runs (this is how it&#8217;s set up in the full program).</p>

<h2>The if Statement</h2>

<pre><code>if( argc != 1)
    printf("Usage: find -x -n pattern\n");
else
    /* Main program logic goes here */
</code></pre>

<p>The last and final part is the if statement. It prints an error/usage message if <code>argc</code> is not equal to 1. Why? Because there should always be one argument left after the flags are processed (the <code>PATTERN</code> argument). The error will also be printed if the program is given an unrecognized flag and the default case in the switch is executed. If there aren&#8217;t any problems, then it executes the else where the main part of the program is contained.</p>

<p>So there you have it. That&#8217;s how Kernigham and Ritchie did it in 1978. Nowadays they just haul in the software weenies with their fancy objects and methods. Lost is the subtle art of manipulating arrays of pointers to strings of characters. Alas. (Just kidding. After all, I&#8217;m probably one of those software weenies.)</p>
</div>

  <footer>
    
    <p><a class="comments-link" href="/blog/blog/2011/08/04/how-old-school-c-programmers-process-arguments/#disqus_thread">View comments &raquo;</a></p>
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/blog/2011/08/03/fibonacci-sequence-part-ii/">Fibonacci Sequence, Part II</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2011-08-03T16:49:00-06:00" pubdate data-updated="true">Aug 3<span>rd</span>, 2011</time>
         &bull; <a rel="bookmark" href="/blog/blog/2011/08/03/fibonacci-sequence-part-ii/">&infin;</a>
      </p>
    
  </header>

<div class="entry-content"><p>The matrix equation in the last post can actually be whittled down a bit further to produce another equation that, in some ways, is easier to work with. The result is as follows:</p>

<p><img src="http://media.usrsb.in/fib2/fib.png" alt="fib" /></p>

<p>F<sub>k</sub> is, of course, the k<sup>th</sup> Fibonacci number. Now, before I go on, I want to point out that I stumbled upon these two equations and the proofs for these equations in <a href="http://www-math.mit.edu/~gs/">Gilbert Strang&#8217;s</a> excellent <a href="http://www.amazon.com/Linear-Algebra-Applications-Gilbert-Strang/dp/0030105676/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1312385275&amp;sr=1-2">Linear Algebra and Its Applications</a>. All credit goes to him for coming up with this, and I recommend his book for an even more in depth explanation.</p>

<p>Anyway, back to the equation, which I found interesting for a few reasons:</p>

<ol>
<li>This equation allows you to easily find the kth term using only a pocket calculator. The last equation requires something that can deal with matrices.</li>
<li>This also makes it easier to use in programming applications. There&#8217;s no need to write functions or import libraries to deal with matrices. It&#8217;s also probably faster than writing some sort of recursive function to compute the kth Fibonacci number.</li>
<li>As Strang points out, that equation, amazingly, produces an integer, despite all the fractions and square roots.</li>
<li>We can simplify that equation further for a very good approximation (so good that it&#8217;s not really an approximation).</li>
</ol>


<p>To see how we get that equation from the equation in the last post, let&#8217;s begin with the way Mr. Strang has it written in his book (it&#8217;s the same as mine, but flipped upside down).</p>

<p><img src="http://media.usrsb.in/fib2/fibmat.png" alt="title" /></p>

<p>Where F<sub>0</sub>=0, F<sub>1</sub>=1, F<sub>2</sub>=1, etc. Let&#8217;s now make some substitutions:</p>

<p><img src="http://media.usrsb.in/fib2/subs.png" alt="title" /></p>

<p>We now have:</p>

<p><img src="http://media.usrsb.in/fib2/matform.png" alt="title" /></p>

<p>This hasn&#8217;t changed the content of the equation at all. We&#8217;ve just substituted in new symbols to represent the different terms.</p>

<p>The next step is to diagonalize the matrix A. Remember that diagonalizing A produces A = SΛS<sup>-1</sup> where S contains A&#8217;s eigenvectors and Λ contains A&#8217;s eigenvalues. Substituting A = SΛS<sup>-1</sup> into the previous equation yields:</p>

<p><img src="http://media.usrsb.in/fib2/diag.png" alt="title" /></p>

<p>Notice how everything but the first and last S and S<sup>-1</sup> cancel, giving the final form: SΛ<sup>k</sup>S<sup>-1</sup>u<sub>0</sub>. This is important, because Λ is a diagonal matrix, making Λ<sup>k</sup> very simple:</p>

<p><img src="http://media.usrsb.in/fib2/lampow.png" alt="title" /></p>

<p>λ<sub>1</sub> and λ<sub>2</sub> are, of course, the eigenvalues of A. Let&#8217;s now make one last substitution and put all this diagonalization stuff together. First we define c as</p>

<p><img src="http://media.usrsb.in/fib2/csub.png" alt="title" /></p>

<p>Then we substitute it into the equation:</p>

<p><img src="http://media.usrsb.in/fib2/diag2.png" alt="title" /></p>

<p>That might need some explaining. The first bit is simply the equation with c substituted in. Following that, the first matrix is S, but written to show that it contains x<sub>1</sub> and x<sub>2</sub>, which are the eigenvectors of A placed vertically in the two columns. The middle matrix is Λ<sup>k</sup> and the last is simply the matrix c. Finally, the matrices are multiplied out, yielding the final c<sub>1</sub>λ<sup>k</sup><sub>1</sub>x<sub>1</sub>+c<sub>2</sub>λ<sup>k</sup><sub>2</sub>x<sub>2</sub></p>

<p>The final steps are simply to compute c, and A&#8217;s eigenvalues and eigenvectors. I&#8217;ll spare you the tedious algebra and simply tell you that:</p>

<p><img src="http://media.usrsb.in/fib2/eigenvals.png" alt="title" /></p>

<p><img src="http://media.usrsb.in/fib2/eigenvec.png" alt="title" /></p>

<p>This can be computed the standard way, by solving: det(A-λI)=0.</p>

<p>All the variables are then plugged into the equation for u<sub>k</sub>.</p>

<p><img src="http://media.usrsb.in/fib2/almost-there.png" alt="title" /></p>

<p>We want F<sub>k</sub>, so we multiply, factor, and take the bottom row, giving the equation we want:</p>

<p><img src="http://media.usrsb.in/fib2/approx.png" alt="title" /></p>

<p>That&#8217;s the full equation, but now notice that the second term is always less than 1/2. This mean we can simply drop it, yielding:</p>

<p>In fact, since the second term is always less than 1/2 and the full equation always gives us an integer, we can take this a step further: <strong>Rounding the approximation to the nearest integer will always give you the exact value for F<sub>k</sub>.</strong> Cool.</p>
</div>

  <footer>
    
    <p><a class="comments-link" href="/blog/blog/2011/08/03/fibonacci-sequence-part-ii/#disqus_thread">View comments &raquo;</a></p>
    
    
  </footer>


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/blog/page/5/">&larr; Older</a>
    
    <a href="/blog/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/blog/page/3/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/blog/2012/05/20/did-the-boulder-pd-reduce-traffic-accidents/">Did the Boulder PD Reduce Traffic Accidents?</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2012/05/05/permutations-an-interview-question/">Permutations: An Interview Question</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2012/04/07/look-ma-no-loops/">Look, Ma! No Loops: Reversing Word Order</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2012/04/01/building-data-structures-from-functions/">Building Data Structures from Functions</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2012/02/05/super-bowl-probabilities/">Super Bowl Probabilities: The Coin Toss</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/beala">@beala</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'beala',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/blog/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("beala", 4, false);
    });
  </script>
  <script src="/blog/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/beala" class="twitter-follow-button" data-show-count="false">Follow @beala</a>
  
</section>


<section>
  <h1>My Pinboard</h1>
  <ul id="pinboard_linkroll">Fetching linkroll&#8230;</ul>
  <p><a href="http://pinboard.in/u:beala">My Pinboard Bookmarks &raquo;</a></p>
</section>
<script type="text/javascript">
  var linkroll = 'pinboard_linkroll'; //id target for pinboard list
  var pinboard_user = "beala"; //id target for pinboard list
  var pinboard_count = 3; //id target for pinboard list
  (function(){
    var pinboardInit = document.createElement('script');
    pinboardInit.type = 'text/javascript';
    pinboardInit.async = true;
    pinboardInit.src = '/javascripts/pinboard.js';
    document.getElementsByTagName('head')[0].appendChild(pinboardInit);
  })();
</script>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Alex Beal -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'usrsbin';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
