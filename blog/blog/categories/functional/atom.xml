<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: functional | /usr/sbin/blog]]></title>
  <link href="http://usrsb.in/blog/blog/categories/functional/atom.xml" rel="self"/>
  <link href="http://usrsb.in/blog/"/>
  <updated>2012-03-16T20:17:10-06:00</updated>
  <id>http://usrsb.in/blog/</id>
  <author>
    <name><![CDATA[Alex Beal]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Making Data Structures from Functions]]></title>
    <link href="http://usrsb.in/blog/blog/2012/03/16/making-data-structures-from-functions/"/>
    <updated>2012-03-16T08:41:00-06:00</updated>
    <id>http://usrsb.in/blog/blog/2012/03/16/making-data-structures-from-functions</id>
    <content type="html"><![CDATA[<p>Here's a puzzle I've adapted form <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_sec_2.1.3">exercise 2.4</a> of SICP.</p>

<blockquote><p>Suppose I were programming in a language that only supported function application. That is, all that could be done in this language is define functions, and apply arguments to those functions. How could I model linked lists in such a language? Is it possible?</p></blockquote>

<p>Surprisingly, the answer is yes, and the exercise linked to above provides a partial solution. Below, I've translated that solution into Python, and completed the exercise:</p>

<p>```python Solution in Python</p>

<h1>Create a pair from l and r</h1>

<p>def cons(l, r):</p>

<pre><code>return lambda get: get(l, r)
</code></pre>

<h1>Given a pair, return the head (left) value.</h1>

<p>def head(pair):</p>

<pre><code>return pair(lambda l, r: l)
</code></pre>

<h1>Give a pair, return the tail (right) value.</h1>

<p>def tail(pair):</p>

<pre><code>return pair(lambda l, r: r)
</code></pre>

<p>```</p>

<p>First, let's examine how these functions can be used, and then I'll explain how they work. Consider the snippet below:</p>

<p><code>python Usage Example
l1 = cons(1, 2)
print head(l1)       # Prints 1
print tail(l1)       # Prints 2
l2 = cons(0, l1)
print head(l2)       # Prints 0
print head(tail(l2)) # Prints 1
print tail(tail(l2)) # Prints 2
</code></p>

<p>As can be seen, <code>cons()</code> is a constructor for this pair type. Give it two values, and it will create a pair of those two values. <code>head()</code> and <code>tail()</code> are the basic operators that let us access values inside these pairs; they return the left and right element of the pair, respectively. Also notice that we can create pairs of pairs. The last half of the example creates a pair composed of <code>0</code> and <code>(1,2)</code>. Why is this significant? Well, we've just made a linked list! Linked lists are simply pairs of pairs. The list <code>[1,2,3,4]</code> can, for example, be represented as <code>cons(1,cons(2,cons(3,cons(4,None))))</code>. Incredible! What's <code>None</code> doing at the end of the list? You can think of it like the <code>NULL</code> pointer at the end of a linked list in C. If a function were traversing the list, <code>None</code> would signify to the function that it has reached the end. Mathematically, you can think of a linked list as an inductively defined data structure, where <code>None</code> is the base case. <code>None</code> is referred to as the <em>empty list</em>.</p>

<p>This is a pony.</p>
]]></content>
  </entry>
  
</feed>
